---
title: 数据结构与算法之美笔记——递归
categories:
  - 数据结构与算法
tags:
  - 数据结构与算法之美笔记
p: data_structure_algorithm\数据结构与算法之美笔记——递归
date: 2019-05-12 09:51:35
mathjax: true
---

**摘要:**

> 递归是一种经常遇到的算法，主要用于一个问题可拆解为多个相似解决思路的小问题进行解决，递归的优势就是代码简洁高效，但是递归也会存在堆栈溢出、发生重复计算、空间复杂度较高等问题。

### 递归

递归在编程技巧中十分常见，当一个大问题可拆解为多个类似解决思路的小问题时便可以使用递归，但是书写递归代码很多人会觉得复杂，其实递归代码的书写也有自己的技巧。

分析递归的过程其实主要是在分析其「**递推公式**」和「**结束条件**」，举个生活中的例子，比如排队时你想知道自己是排在第几个，可以一个个自己数，但也可以问排前一位的人是排第几个，加一位就是自己当前排队的位置，那如果前一位也不知道自己具体排在第几位呢，同样他也可以用同样的方式询问排前面的一位，那有谁可以完全明确自己的排队位置呢，排在第 1 位的肯定能明确自己的位置是第 1，因为他前面已经没有人了。

这个实际中的例子将一个确定自己排队位置的问题分解为了询问自己前一位的位置加一的方式解决，前一位也通过类似的解决方式来确定自己的位置，直到排在第一位的人明确自己的位置是第一位。按照分析可以得到递推公式和结束条件如下：
> 递推公式：$f(n)=f(n-1)+1$
结束条件：$f(1)=1$

转换为代码如下：

```java
public int f(n) {
  if(n == 1) {return 1;}
  return f(n - 1) + 1;
}
```

这里可以看出递归可以使代码简洁高效，这也是递归的优势，但并不是说所有的问题都适合使用递归进行解决，一般能够满足以下三个条件的问题比较适合使用递归解决。

- **一个问题可以拆分为诸多小问题解决**

比如排队例子确定「自己排在第几个位置」这个问题就可以分解为「询问自己前一位的人的排队位置」。

- **一个问题拆分的小问题与其本身具有相似的解决思路**

比如排队例子中的子问题「询问在自己前一位的人的排队位置」与「明确自己排队所在位置」有同样的解决思路，就是「再询问排队在自己之前的人所在排队位置」。

- **能够找到递归的结束条件**

在排队例子中的递归结束条件就是「排队在第一位人肯定能明确自己所排位置为第一位」。

### 递归的劣势

#### 堆栈溢出

当调用方法时，在调用方法之前被声明的临时变量会被存储在栈中，等待临时方法被调用结束之后再将临时变量取出恢复现场，如果递归过深，大量的临时变量被存储栈中，必然会造成堆栈的溢出，这个问题可以通过限制递归深度来解决。

#### 重复计算问题

在排队例子中没有体现重复计算问题，我们可以换个例子，例如[斐波那契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)，斐波那契数列符合使用递归的条件，递推公式及结束条件如下：

> 递推公式：$f(n)=f(n-1)+f(n-2) (n\geq2)$
结束条件：$f(1)=1$ $f(0)=0$

如果计算第3位的数时就会如下图：
![](https://upload-images.jianshu.io/upload_images/16871983-4b2f04177bf4d27f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从图中可以看出对 `f(1)` 存在重复计算，如果要解决这个问题可以使用一个数据结构将计算结果存储起来，每次计算前查看是否有相应的计算结果，如果有计算结果就取出使用，如果没有就进行计算并把相应计算结果存储起来。

#### 空间复杂度高

在排队例子中分析代码空间复杂度为 $O(1)$，但是因为递归在调用方法时会造成存储空间的累积，所以排队例子代码的空间复杂度应该为 $O(n)$。

递归代码虽然简洁但有相应的劣势，除了以上描述的解决方案之外其实还可以将递归代码转化为循环进行解决，因为归根结底递归也是对问题的循环解决，比如排队问题的代码可以修改为如下的循环：

```java
public int f(n) {
  int position = 1;
  for(int i = 2; i <= n; i++) {
    position++;
  }
  return position;
}
```

### 总结

递归适宜于大问题可以分割为有相似解决方案的小问题的场景，写出递归代码的关键在于找到递归公式和递归结束条件，使用递归可以使代码表达更加简洁，但也会存在堆栈溢出，重复计算及空间复杂度高等问题，堆栈溢出与空间复杂度高可以通过限制递归深度解决，重复计算可以通过存储计算值避免。

****
> **文章中如有问题欢迎留言指正
数据结构与算法之美笔记系列将会做为我对王争老师此专栏的学习笔记，如想了解更多王争老师专栏的详情请到极客时间自行搜索。**