---
title: 数据结构与算法之美笔记——树与二叉树
categories:
  - 数据结构与算法
tags:
  - 数据结构与算法之美笔记
p: data_structure_algorithm\数据结构与算法之美笔记——树与二叉树
date: 2019-08-10 13:39:21
mathjax: true
---

**摘要:**

> 树是一种非线性表结构，多用链表的方式存储，也可使用数组存储，以节点为数据存储单元，节点的链接表示父子关系，二叉树是树的其中一种，一个父节点最多可以有两个子节点，遍历节点的时间复杂度为 $O(n)$。

### 树（Tree）

#### 树长什么样

这种数据结构称为树，那一定和现实中的树存在着某些联系。首先我们来回忆一下现实中的树是什么模样，树都由根长起，然后分叉为枝丫，枝丫顶端生长出叶子，数据结构中的树也是类似的样子，只不过将现实中的树颠倒过来，树的关键位置都统称为「**节点（Node）**」，树的根称为「**根节点**」，叶子称为「**叶子节点**」，树枝分叉的位置也是节点，节点之间依靠树枝连接，直接连接的节点间存在父子关系，离根节点更近的是「**父节点**」，父结点分叉出直接相连的节点是它的「**子节点**」。

![](https://i.loli.net/2019/08/10/L5AdQPvEocqhFtn.png)

#### 树的三个属性

树除了以上介绍的特点以外还有三个属性，分别是「**高度（Height）**」、「**深度（Depth）**」和「**层（Level）**」，高度又有节点的高度和树的高度，几个属性的解释如下。

> 节点的高度 = 节点到叶子节点的最大边数
节点的深度 = 根节点到节点的边数
节点的层数 = 节点的深度 + 1
树的高度 = 根节点的高度

节点的高度和深度看起来很相似，不过是参照物不同而已，描述高度时的参照物是叶子节点，描述深度的参照物是根节点，这与现实生活中描述高度和深度是一致的。树只是对这一类型数据结构的统称，它也分为很多种类型，接下来介绍一下二叉树。

### 二叉树（Binary Tree）

现实中的树可以分叉多个枝丫，而数据结构中的树也是如此，而二叉树就是规定最多只能分叉两个枝丫，这意味着一个节点最多只能有两个子节点，结点分布在左右两边，以左边节点为根节点构成的树称为「**左子树**」，以右边子节点为根节点构成的树就是「**右子树**」。

#### 二叉树中的特殊类型

即便二叉树看起来如此平凡，但不免也会出现几个骨骼精奇的特殊形态。如下图，一号树就是普通二叉树，而二号树每一层都处于满节点状态，这种二叉树被称为「**满二叉树**」，当然还有三号树，初看之下并不觉得其有什么特点，但仔细分析，三号树除了最后一层外其他层都是满节点状态，最后一层为满节点或右边连续缺少若干节点，这种二叉树被称为「**完全二叉树**」，这样看来满二叉树只是完全二叉树的一种特殊形态。

![](https://i.loli.net/2019/08/10/NW1OwXdY9VrKeJn.png)

满二叉树的特殊容易理解，但完全二叉树有何特殊之处？这个问题要从二叉树的存储形式说起，普遍情况下树都是使用链表进行存储，链表节点除存储自身数据外还存储左子节点指针和右子节点指针，但是树也可以使用数组存储，接下来用二叉树举例说明一下数组是如何存储树的。

首先将根节点存储在下标为 1 的数组元素中，根元素的左子节点存储在下标为 2 * 1 的数组元素中，右子节点存储在下标为 2 * 1 + 1 的数组元素中，其他节点也以同样规则存储，当前节点存储在下标为 i 的数组元素中，当前节点的左子节点存储在下标为 2 * i 的数组元素中，右子节点存储在下标为 2 * i + 1 的数组元素中，当前节点的父节点就存储在下标为 i / 2 的数组元素中。试想一下如果存储的是满二叉树或者完全二叉树时，节点的存储是连续的，而其他的二叉树都会出现数组元素空缺的状态，这也正是完全二叉树的特殊之处。

本来利用链表存储树挺不错的，为啥非要使用数组？使用链表时，存储子节点指针需要消耗存储空间，如果是数组就不存在这样的问题，数组获取当前节点的父节点的操作更加便捷，不过如果不是存储满二叉树或者完全二叉树时，数组中也会浪费大量的存储空间，所以在树的存储上普遍都是使用链表。

#### 遍历二叉树

树的形态特殊，想要遍历树也有些方式方法，分别是「**前序遍历**」、「**中序遍历**」和「**后序遍历**」。这里的前中后都是以当前节点来说，当前节点存在左子节点和右子节点，要遍历这三个节点就有不同的顺序，而左子节点要保持在右子节点之前遍历，于是出现三种遍历顺序，如下所示。

> 中->左->右 前序遍历
左->中->右 中序遍历
左->右->中 后序遍历

##### 代码实现

说了那么多，不如来段代码解解乏。

```java
private class Node {
    private Node left;
    private Node right;
    private int data;


    public Node(int data) {
        this.data = data;
    }

    public void buildChildren(Node left, Node right) {
        this.left = left;
        this.right = right;
    }
}

public Node root;

public BinaryTree(int[] nodes) {
    root = buildTree(1, nodes);
}

private Node buildTree(int currIndex, int[] nodes) {
    if(currIndex >= nodes.length || nodes[currIndex] < 0) {
        return null;
    }

    Node node  = new Node(nodes[currIndex]);
    node.buildChildren(buildTree(currIndex * 2, nodes),buildTree(currIndex * 2 + 1, nodes));

    return node;
}

public void printNodesBefore(Node node) {
    if(node.left == null && node.right == null) {
        System.out.print(node.data + " ");
        return;
    }

    System.out.print(node.data + " ");
    System.out.print(node.data + "'s left:");
    printNodesBefore(node.left);
    System.out.print(node.data + "'s right:");
    printNodesBefore(node.right);
}
```

代码中我用递归的方式实现了前序遍历，关于中序遍历和后序遍历的实现可以到我的 [Git 仓库](https://github.com/CloneableX/data_structures_algorithm/tree/master/tree/src) 中查看。

##### 遍历的时间复杂度

单独看递归方法中的代码时间复杂度是 $O(1)$，但是递归的时间复杂度需要累积计算，遍历有 n 个结点的二叉树时间，需要递归 n 次，所以遍历二叉树节点的时间复杂度就是 $O(n)$。

### 总结

树是一种非线性表结构，使用节点作为数据存储单元，可以利用链表或者数组实现，链表实现的方式更加普遍。

二叉树是树的一种类型，一个节点最多只允许有两个子节点，二叉树中存在完全二叉树和满二叉树两种特殊形态，遍历二叉树可以使用前序、中序和后序三种遍历方式，二叉树遍历的时间复杂度是 $O(n)$。

****
> **文章中如有问题欢迎留言指正
本章节代码已经上传GitHub，可[点击跳转](https://github.com/CloneableX/data_structures_algorithm/tree/master/tree/src)查看代码详情。
数据结构与算法之美笔记系列将会做为我对王争老师此专栏的学习笔记，如想了解更多王争老师专栏的详情请到极客时间自行搜索。**